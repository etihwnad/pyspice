<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.287401574803">
	<global_window_position top="0" left="0" height="687" width="1276"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="dan.20080319143651" str_leo_pos="4,6,0"><vh>@chapters</vh></v>
<v t="dan.20070210134628" tnodeList="dan.20070210134628,etihwnad.20060605202632.1"><vh>@file Roadmap</vh>
<v t="etihwnad.20060605202632.1"><vh>todo</vh></v>
</v>
<v t="dan.20070210134929" tnodeList="dan.20070210134929"><vh>@file HISTORY</vh></v>
<v t="dan.20070210134747" tnodeList="dan.20070210134747"><vh>@file README</vh></v>
<v t="etihwnad.20060606092308.1" a="E" tnodeList="etihwnad.20060606092308.1,etihwnad.20060605200356.2,etihwnad.20060605202504,etihwnad.20060605201903,dan.20061011115934,dan.20061111103052,dan.20080325141426,dan.20061011120652,dan.20061011120117,etihwnad.20060605210612,etihwnad.20060605205852,etihwnad.20060609195838,etihwnad.20060605200356.36,etihwnad.20060605211347,dan.20070113152139,dan.20070113152139.1,etihwnad.20060605200356.32,etihwnad.20060605200356.33,etihwnad.20060605200356.34,dan.20061229140222,dan.20061229141817,dan.20080323201044,dan.20061229215859,dan.20061229142604,dan.20061229142423,dan.20080323183246,dan.20061229141501,dan.20080325131728,dan.20061229231842,dan.20061229231842.1,dan.20061229231842.2,dan.20061008213431,etihwnad.20060605200356.3,etihwnad.20060605200356.4,etihwnad.20060605200356.5,etihwnad.20060605200356.6,etihwnad.20060605200356.11,etihwnad.20060605200356.12,etihwnad.20060605200356.13,etihwnad.20060605200356.14,dan.20061008213532,dan.20061008213532.1,dan.20061008213532.2,dan.20061008214054,dan.20061008214054.1,dan.20061008214054.2,dan.20061008213431.1,etihwnad.20060605200356.7,etihwnad.20060605200356.8,etihwnad.20060605200356.9,etihwnad.20060605200356.10,etihwnad.20060605200356.15,etihwnad.20060605200356.16,etihwnad.20060605200356.17,etihwnad.20060605200356.18,etihwnad.20060612195947,etihwnad.20060612195947.1,etihwnad.20060612195947.2,etihwnad.20060612195947.3,etihwnad.20060605200356.19,etihwnad.20060605200356.20,etihwnad.20060605200356.21,etihwnad.20060605200356.22,etihwnad.20060605200356.23,etihwnad.20060605200356.24,etihwnad.20060605200356.25,dan.20061008213903,dan.20061008213903.1,dan.20061008213936,dan.20061008213936.1,dan.20080323214255,dan.20080323214255.1,dan.20080323223326,etihwnad.20060609195838.1,etihwnad.20060612075426,etihwnad.20060605200356.27,etihwnad.20060605200356.26,etihwnad.20060605200356.28,dan.20080323201405"><vh>@nosent pyspice.py</vh>
<v t="etihwnad.20060605200356.2"><vh>&lt;&lt; head docstring&gt;&gt;</vh>
<v t="etihwnad.20060605202504"><vh>&lt;&lt; head &gt;&gt;</vh></v>
<v t="etihwnad.20060605201903"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="dan.20061011115934" a="E"><vh>&lt;&lt; release notes &gt;&gt;</vh>
<v t="dan.20061111103052"><vh>v0.3</vh></v>
<v t="dan.20080325141426"><vh>v0.2a</vh></v>
<v t="dan.20061011120652"><vh>v0.2</vh></v>
<v t="dan.20061011120117"><vh>v0.1</vh></v>
</v>
</v>
<v t="etihwnad.20060605210612"><vh>&lt;&lt; global imports &gt;&gt;</vh></v>
<v t="etihwnad.20060605205852"><vh>&lt;&lt; global vars &gt;&gt;</vh></v>
<v t="etihwnad.20060609195838"><vh>Option processing</vh>
<v t="etihwnad.20060605200356.36"><vh>options</vh></v>
</v>
<v t="etihwnad.20060605211347" a="E"><vh>classes</vh>
<v t="dan.20070113152139"><vh>exceptions</vh>
<v t="dan.20070113152139.1"><vh>class UnitError</vh></v>
<v t="etihwnad.20060605200356.32"><vh>class ElementError</vh>
<v t="etihwnad.20060605200356.33"><vh>__init__</vh></v>
<v t="etihwnad.20060605200356.34"><vh>__str__</vh></v>
</v>
</v>
<v t="dan.20061229140222"><vh>class Netlist</vh>
<v t="dan.20061229141817"><vh>__init__</vh></v>
<v t="dan.20080323201044"><vh>_addMassagedLine</vh></v>
<v t="dan.20061229215859"><vh>addElement</vh></v>
<v t="dan.20061229142604"><vh>addLine</vh></v>
<v t="dan.20061229142423"><vh>classify</vh></v>
<v t="dan.20080323183246"><vh>massageLine</vh></v>
<v t="dan.20061229141501"><vh>readfile</vh></v>
<v t="dan.20080325131728"><vh>removeElement</vh></v>
</v>
<v t="dan.20061229231842"><vh>class ElementHandler</vh>
<v t="dan.20061229231842.1"><vh>__init__</vh></v>
<v t="dan.20061229231842.2"><vh>add_handler</vh></v>
</v>
<v t="dan.20061008213431"><vh>base classes</vh>
<v t="etihwnad.20060605200356.3"><vh>class SpiceElement</vh>
<v t="etihwnad.20060605200356.4"><vh>__init__</vh></v>
<v t="etihwnad.20060605200356.5"><vh>__str__</vh></v>
<v t="etihwnad.20060605200356.6"><vh>drop</vh></v>
</v>
<v t="etihwnad.20060605200356.11"><vh>class Passive2NodeElement</vh>
<v t="etihwnad.20060605200356.12"><vh>__init__</vh></v>
<v t="etihwnad.20060605200356.13"><vh>__str__</vh></v>
<v t="etihwnad.20060605200356.14"><vh>drop</vh></v>
</v>
<v t="dan.20061008213532"><vh>class Active2NodeElement</vh>
<v t="dan.20061008213532.1"><vh>__init__</vh></v>
<v t="dan.20061008213532.2"><vh>__str__</vh></v>
</v>
<v t="dan.20061008214054"><vh>class Active4NodeElement</vh>
<v t="dan.20061008214054.1"><vh>__init__</vh></v>
<v t="dan.20061008214054.2"><vh>__str__</vh></v>
</v>
</v>
<v t="dan.20061008213431.1"><vh>element classes</vh>
<v t="etihwnad.20060605200356.7"><vh>class CommentLine</vh>
<v t="etihwnad.20060605200356.8"><vh>__init__</vh></v>
</v>
<v t="etihwnad.20060605200356.9"><vh>class ControlElement</vh>
<v t="etihwnad.20060605200356.10"><vh>__init__</vh></v>
</v>
<v t="etihwnad.20060605200356.15"><vh>class Capacitor</vh>
<v t="etihwnad.20060605200356.16"><vh>__init__</vh></v>
<v t="etihwnad.20060605200356.17"><vh>isparallel</vh></v>
<v t="etihwnad.20060605200356.18"><vh>combine</vh></v>
</v>
<v t="etihwnad.20060612195947"><vh>class Inductor</vh>
<v t="etihwnad.20060612195947.1"><vh>__init__</vh></v>
<v t="etihwnad.20060612195947.2"><vh>isparallel</vh></v>
<v t="etihwnad.20060612195947.3"><vh>combine</vh></v>
</v>
<v t="etihwnad.20060605200356.19"><vh>class Mosfet</vh>
<v t="etihwnad.20060605200356.20"><vh>__init__</vh></v>
<v t="etihwnad.20060605200356.21"><vh>__str__</vh></v>
<v t="etihwnad.20060605200356.22"><vh>isparallel</vh></v>
<v t="etihwnad.20060605200356.23"><vh>combine</vh></v>
</v>
<v t="etihwnad.20060605200356.24"><vh>class Resistor</vh>
<v t="etihwnad.20060605200356.25"><vh>__init__</vh></v>
</v>
<v t="dan.20061008213903"><vh>class Vsource</vh>
<v t="dan.20061008213903.1"><vh>__init__</vh></v>
</v>
<v t="dan.20061008213936"><vh>class Isource</vh>
<v t="dan.20061008213936.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="dan.20080323214255"><vh>functions</vh>
<v t="dan.20080323214255.1"><vh>combineCapacitorsInplace</vh></v>
<v t="dan.20080323223326"><vh>combineMosfetsInplace</vh></v>
</v>
<v t="etihwnad.20060609195838.1" a="E"><vh>helpers</vh>
<v t="etihwnad.20060612075426"><vh>unit</vh></v>
<v t="etihwnad.20060605200356.27"><vh>debug</vh></v>
<v t="etihwnad.20060605200356.26"><vh>info</vh></v>
<v t="etihwnad.20060605200356.28"><vh>warning</vh></v>
</v>
<v t="dan.20080323201405"><vh>main</vh></v>
</v>
<v t="dan.20070113143715" tnodeList="dan.20070113143715,dan.20070113145158,dan.20070113154450"><vh>@file test_pyspice.py</vh>
<v t="dan.20070113145158"><vh>unit conversions</vh></v>
<v t="dan.20070113154450"><vh>netlist parsing</vh></v>
</v>
<v t="dan.20080324085048"><vh>old</vh>
<v t="etihwnad.20060605200356.35"><vh>classify</vh></v>
<v t="etihwnad.20060605200356.29"><vh>drop_2node</vh></v>
<v t="etihwnad.20060605200356.37"><vh>old_main</vh></v>
<v t="etihwnad.20060605200356.31"><vh>read_netlist</vh>
<v t="etihwnad.20060609200142"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="etihwnad.20060609200142.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
</v>
<v t="etihwnad.20060605200356.30"><vh>write_2node</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="dan.20061008213431">@
These classes are used to break down the spectrum of SPICE elements
into 'classes' of elements.  I.e. 2 node passives, 2-node sources, 4-node sources,
and so on.  The elements found in a real netlist are based on these types.
@c
</t>
<t tx="dan.20061008213431.1">@
This is a(n incomplete) definition of the various SPICE elements.

NOTE: When adding a new element type definition, be sure to add a handler
  for the new class after defining the class using:
      elements.add_handler('x', Xdevice)
@c
#make a repository for element handlers
_elementHandler = ElementHandler()
</t>
<t tx="dan.20061008213532">
class Active2NodeElement(SpiceElement):
    """Base class for active 2-node elements.
    Assumes SPICE element line:
    xXXX n1 n2 value p1=val p2=val ...
    Inherits:
        None
    Redefines:
        None
    """
	@others
</t>
<t tx="dan.20061008213532.1">def __init__(self, line, num):
    SpiceElement.__init__(self, line, num)
    self.type = 'active2'
    self.typeName = 'Active2NodeElement'
    arr = line.split()
    self.name = arr[0]
    self.n1 = _current_scope + arr[1]
    self.n2 = _current_scope + arr[2]
    self.value = unit(arr[3])
    self.param = dict() #store x = y as dictionary
    for p in arr[4:]:
        k, v = p.split('=')
        self.param[k] = unit(v)
</t>
<t tx="dan.20061008213532.2">def __str__(self):
    """Returns the netlist-file representation of this element"""
    s = StringIO()

    print&gt;&gt;s, self.name, self.n1, self.n2, self.value,

    for k, v in self.param.iteritems():
        print&gt;&gt;s, k + '=' + str(v),

    return _wrapper.fill(s.getvalue())
</t>
<t tx="dan.20061008213903">
class Vsource(Active2NodeElement):
    """Assumes SPICE element line:

    vXXX n1 n2 value p1=val p2=val ...
    """
	@others
_elementHandler.add_handler('v', Vsource)
</t>
<t tx="dan.20061008213903.1">def __init__(self, line, num):
    Active2NodeElement.__init__(self, line, num)
    self.type = 'v'
    self.typeName = 'Vsource'
</t>
<t tx="dan.20061008213936">
class Isource(Active2NodeElement):
    """Assumes SPICE element line:

    iXXX n1 n2 value p1=val p2=val ...
    """
	@others
_elementHandler.add_handler('i', Isource)
</t>
<t tx="dan.20061008213936.1">def __init__(self, line, num):
    Active2NodeElement.__init__(self, line, num)
    self.type = 'i'
    self.typeName = 'Isource'
</t>
<t tx="dan.20061008214054">
class Active4NodeElement(SpiceElement):
    """Base class for active 4-node elements (xCyS).
    Assumes SPICE element line:
    xXXX n1 n2 value p1=val p2=val ...
    Inherits:
        None
    Redefines:
        None
    """
	@others
</t>
<t tx="dan.20061008214054.1">def __init__(self, line, num):
    SpiceElement.__init__(self, line, num)
    self.type = 'active4'
    self.typeName = 'Active4NodeElement'
    arr = line.split()
    self.name = arr[0]
    self.n1 = _current_scope + arr[1]
    self.n2 = _current_scope + arr[2]
    self.n3 = _current_scope + arr[3]
    self.n4 = _current_scope + arr[4]
    self.value = unit(arr[5])
    self.param = dict() #store x = y as dictionary
    for p in arr[6:]:
        k, v = p.split('=')
        self.param[k] = unit(v)
</t>
<t tx="dan.20061008214054.2">def __str__(self):
    s = StringIO()
    print&gt;&gt;s, self.name, self.n1, self.n2, self.n3, self.n4, self.value,
    for k, v in self.param.iteritems():
        #are there instances when 0 is (in)significant?
        #if v == 0: continue
        print&gt;&gt;s, k + '=' + str(v),
    return _wrapper.fill(s.getvalue())
</t>
<t tx="dan.20061011115934">Release Notes, changelog
-----------------------------------------------------
@others
</t>
<t tx="dan.20061011120117">pyspice v0.1:
-------------
Initial release.
Only worked for netlist containing MOSFETs and Capacitors.
</t>
<t tx="dan.20061011120652">pyspice.py v0.2:
----------------
-At least default (pass through) handling of all element types.
NOTE: For combining, this uses a global node name scheme.  In other
    words: subcircuits, libraries, etc. are not in a separate node
    namespace as they should be, beware.
-Changed structure of classes (in LEO), there are base classes that contain
    common attributes and element classes that define the specific behavior.
-This version _should_ work with any netlist and only touch M's and C's, YMMV.
-Work is ongoing on the class structure and most important IMO is getting netlist
    hierarchy implemented. 

</t>
<t tx="dan.20061111103052">pyspice.py v0.3:
----------------
-entire netlist is held in the top level Netlist object
-temporarily does not drop small capacitors
-code cleanup

</t>
<t tx="dan.20061229140222">
class Netlist:
    """Base class that holds an entire netlist.

    Notes:
        -this will eventually hold the entire shebang
        -providing __init__ with a file name will:
            -read in netlist
            -classify the lines
            -take care of hierarchy
            -source other files
    """
    @others
</t>
<t tx="dan.20061229141501">def readfile(self, fname):
    """Read a SPICE netlist from the open file pointer into the netlist.

    Reads the file as a netlist into the deck.  Appends the line's text
    and adds a classified SpiceElement to the deck.

    return:
        None

    Note:
        -we need to read at least a full line with continuations before we can
         add the line to the netlist
    """

    if isinstance(fname, file):
        ifp = fname
    else:
        ifp = open(fname, 'rU')

    #first line of any file is ignored
    # typically a title line
    # set title iff title is not set
    line = ifp.readline()
    if not self.title:
        self.title = line

    currentCard = ifp.readline()
    n = 2 #1-indexed line numbers
    for line in ifp:
        n += 1
        #handle line continuations here
        if line[0] == '+':
            currentCard += line[1:]
            continue

        #a new card is started, the previous card is
        #unambiguously finished
        mLine = self.massageLine(currentCard)
        self._addMassagedLine(mLine)
        self.addElement(self.classify(mLine, num=n))
        currentCard = line
</t>
<t tx="dan.20061229141817">def __init__(self, fname=None, title=None):
    """Optionally reads a netlist from a file"""
    self.deck = []
    self.lines = []
    self.title = title

    self.elements = dict()
    for e in _elementHandler.validTypes:
        self.elements[e] = []

    if fname:
        self.readfile(fname)
</t>
<t tx="dan.20061229142423">def classify(self, line, num=None):
    """Takes a line and creates an appropriate SpiceElement"""
    return _elementHandler.handler[line[0][0]](line, num=num)
</t>
<t tx="dan.20061229142604">def addLine(self, line):
    """Add the given non-empty line to netlist after massaging"""
    if line:
        #fail on line continuations
        if line[0] == '+':
            raise PyspiceError('addLine does not handle line continuations')
        else:
            line = self.massageLine(line)
            self._addMassagedLine(line)
</t>
<t tx="dan.20061229215859">def addElement(self, element):
    self.deck.append(element)
    self.elements[element.type].append(element)
</t>
<t tx="dan.20061229231842">class ElementHandler:
    @others
</t>
<t tx="dan.20061229231842.1">def __init__(self):
    self.validTypes = '*.abcdefghijklmnopqrstuvwxyz'
    self.handler = dict()
    for t in self.validTypes:
        self.handler[t] = SpiceElement
</t>
<t tx="dan.20061229231842.2">def add_handler(self, type, handler):
    """Replaces the existing element object definition with the
    given one"""
    self.handler[type] = handler
</t>
<t tx="dan.20070113143715">@first #!/usr/bin/python
@language python
@tabwidth -4
"""Unit test stuff for pyspice.py"""

__author__ = "Dan White (etihwnad@gmail.com)"
__version__ = "$Revision: 1.3 $"
__date__ = "$Date: 2004/05/05 21:57:20 $"
__copyright__ = "Copyright (c) 2007 Dan White"
__license__ = "GPL"

import pyspice
import unittest
from decimal import Decimal as D

@others

if __name__ == "__main__":
    unittest.main()</t>
<t tx="dan.20070113145158">
class unitConversion(unittest.TestCase):
    """Tests conversion between SPICE string and Decimal number."""
    knownValues = ( ('5T',      D('5.0e12')),
                    ('5G',      D('5.0e9')),
                    ('10MEG',   D('10.0e6')),
                    ('342x',    D('342.0e6')),
                    ('15k',     D('15.0e3')),
                    ('1MIL',    D('25.4e-6')),
                    ('435M',    D('435e-3')),
                    ('1U',      D('1.0e-6')),
                    ('67N',     D('67.0e-9')),
                    ('4P',      D('4.0e-12')),
                    ('3F',      D('3.0e-15')) )

    badValues =   ( 'like' )

    def test_unit_knownValues(self):
        """unit() should give known result with known input"""
        for s, num in self.knownValues:
            result = pyspice.unit(s)
            self.assertEqual(num,result)

    def test_unit_badValues(self):
        """unit() should fail with bad input"""
        for s in self.badValues:
            self.assertRaises(pyspice.BadUnitError, pyspice.unit, s)
</t>
<t tx="dan.20070113152139">
class PyspiceError(Exception):
    '''Base exception for pyspice'''
    pass
</t>
<t tx="dan.20070113152139.1">
class BadUnitError(PyspiceError):
    pass

</t>
<t tx="dan.20070113154450">
class netlistParsing(unittest.TestCase):
    """Tests the netlist parser"""
    pass</t>
<t tx="dan.20070210134628">@nocolor
Contained here is the descriptive blueprint of how this package is supposed to work

@others</t>
<t tx="dan.20070210134747">@nocolor
Please see Roadmap for more information on what's currently going on here.
</t>
<t tx="dan.20070210134929">@pagewidth 80
@nocolor

The poorly-documented chronology of this package's development progress.  The intention is to keep me focused on the big picture and just fill in the missing parts.

</t>
<t tx="dan.20080319143651"></t>
<t tx="dan.20080323183246">#finds a "name = value" pair for shrinking
RE_PARAM = re.compile(r"(\S*)\s*=\s*(\S*)")

#finds only whitespace
RE_WHITESPACE_EMPTY = re.compile(r'^\s*$')

def massageLine(self, line):
    #remove trailing newline
    line = line.strip('\r\n')

    #pass through empty lines and convert to comments
    if self.RE_WHITESPACE_EMPTY.search(line):
        return '*'
    # and pass through comments, they stay as-is
    elif line[0] == '*':
        return line

    #case is unimportant in SPICE
    #lowercase all non-comment lines
    line = line.lower()

    #remove whitespace in parameter assignments
    # to prepare for x.split(' ') that happens next:
    #  'as = 3e-12' =&gt; 'as=3e-12'
    line = self.RE_PARAM.sub(r'\1=\2', line)

    return line
</t>
<t tx="dan.20080323201044">def _addMassagedLine(self, line):
    """Add the given non-empty line to netlist.  Assumes the line has already
    been massaged."""
    self.lines.append(line)
</t>
<t tx="dan.20080323201405">def main():
    global _opt
    opt = options()
    _opt = opt

    # output file header
    print&gt;&gt;ofp, "* pyspice.py %s: by Dan White &lt;etihwnad@gmail.com&gt;" % __version__
    print&gt;&gt;ofp, "* mail me bug reports, fixes, and comments if you find this useful"
    print&gt;&gt;ofp, "* ----------------------------------------------------------------"

    # Read and parse given input file (as top-level)
    netlist = Netlist(ifp)

    # Show input statistics
    if opt.v:
        info('Read in %i elements' % len(netlist.deck))
        s = StringIO()
        print&gt;&gt;s, 'Input Element counts:'
        for t, v in netlist.elements.iteritems():
            if len(v):
                print&gt;&gt;s, '%s: %i' % (t, len(v))
        info(s.getvalue())


    # Combine elements if requested
    nCombined = dict()
    if opt.combine_c:
        nCombined['c'] = combineCapacitorsInplace(netlist)
        if opt.v:
            info('Combined %i capacitors' % nCombined['c'])

    if opt.combine_m:
        nCombined['m'] = combineMosfetsInplace(netlist)
        if opt.v:
            info('Combined %i mosfets' % nCombined['m'])

    # Show output statistics
    if opt.v:
        s = StringIO()
        print&gt;&gt;s, 'Output Element counts:'
        for t, v in netlist.elements.iteritems():
            if len(v):
                print&gt;&gt;s, '%s: %i' % (t, len(v))
        info(s.getvalue())
</t>
<t tx="dan.20080323214255"></t>
<t tx="dan.20080323214255.1">def combineCapacitorsInplace(nlist):
    '''Finds all parallel capacitors and replaces each with a single element
    of equivalent value.  The capacitor is named by the first-occuring name.
    Returns the number of combined capacitors.'''

    caps = [c for c in nlist.deck if c.type == 'c']

    #this modifies the list being iterated over in place
    #usually this is BAD, here it is our way of only checking capacitor
    #combinations for parallel-isity once, the netlist is modified in parallel.
    #
    #This works because different instances of the same class never compare
    #equal
    n = 0
    for c in caps:
        for x in caps[caps.index(c)+1:]:
            if c.combine(x):
                n += 1
                caps.remove(x)
                nlist.removeElement(x)

    return n
</t>
<t tx="dan.20080323223326">def combineMosfetsInplace(nlist):
    '''TODO'''

    fets = [m for m in nlist.deck if m.type == 'm']

    n = 0
    for m in fets:
        for x in fets[fets.index(m)+1:]:
            if m.combine(x):
                n += 1
                fets.remove(x)
                nlist.removeElement(x)

    return n
</t>
<t tx="dan.20080324085048"></t>
<t tx="dan.20080325131728">def removeElement(self, element):
    self.deck.remove(element)
    self.elements[element.type].remove(element)
</t>
<t tx="dan.20080325141426">pyspice.py v0.2a:
----------------
-added a missing newline before an import statement

</t>
<t tx="etihwnad.20060605200356.2">"""
&lt;&lt; head &gt;&gt;
&lt;&lt; copyright &gt;&gt;
&lt;&lt; release notes &gt;&gt;
@others
"""
@nocolor
</t>
<t tx="etihwnad.20060605200356.3">
class SpiceElement:
    """Base class for SPICE elements.
    Methods:
        __init__(self, line, num) -&gt; SpiceElement
        __str__(self) -&gt; string spice line
        drop() -&gt; False
    """
	@others
</t>
<t tx="etihwnad.20060605200356.4">def __init__(self, line, num=None):
    """SpiceElement constructor
    line - netlist expanded line
    type - first character
    num  - input netlist line number (for keeping roughly the same
           order when printing modified netlist)
    """
    #accept lists of 'words' also; BE CAREFUL with this, though
    self.line = line
    self.type = 'spice'
    self.typeName = 'SpiceElement'
    self.num = num
</t>
<t tx="etihwnad.20060605200356.5">def __str__(self):
    return _wrapper.fill(self.line)
</t>
<t tx="etihwnad.20060605200356.6">def drop(self, val=0, mode='&lt;'):
    """Template for dropping elements that defaults to NO if
    not overidden in the element class"""
    return False
</t>
<t tx="etihwnad.20060605200356.7">
class CommentLine(SpiceElement):
    """SPICE Comment line (/^\*.*/)
    """
	@others
_elementHandler.add_handler('*', CommentLine)
</t>
<t tx="etihwnad.20060605200356.8">def __init__(self, line, num):
    SpiceElement.__init__(self, line, num)
    self.type = '*'
    self.typeName = ''
</t>
<t tx="etihwnad.20060605200356.9">
class ControlElement(SpiceElement):
    """Control statement object, no processing for now.
    Note: this will eventially be a base class for the real control elements

    Note: currently has no knowledge of blocks (.lib/.endl, .subckt/.ends)
    has only ONE node namespace, make sure subckt's have unique node names!
    """
	@others
_elementHandler.add_handler('.', ControlElement)
</t>
<t tx="etihwnad.20060605200356.10">def __init__(self, line, num):
    SpiceElement.__init__(self, line, num)
    self.type = '.'
    self.typeName = 'ControlElement'
</t>
<t tx="etihwnad.20060605200356.11">
class Passive2NodeElement(SpiceElement):
    """Base class for 2-node elements.
    Assumes SPICE element line:
    xXXX n1 n2 value p1=val p2=val ...
    Inherits:
        None
    Redefines:
        drop(self, val, mode) -&gt; bool
    """
	@others
</t>
<t tx="etihwnad.20060605200356.12">def __init__(self, line, num):
    SpiceElement.__init__(self, line, num)
    self.type = 'passive2'
    self.typeName = 'Passive2NodeElement'
    arr = line.split()
    self.name = arr[0]
    self.n1 = _current_scope + arr[1]
    self.n2 = _current_scope + arr[2]
    self.value = unit(arr[3])
    self.param = dict() #store x = y as dictionary
    for p in arr[4:]:
        k, v = p.split('=')
        self.param[k] = unit(v)
</t>
<t tx="etihwnad.20060605200356.13">def __str__(self):
    """Returns the netlist-file representation of this element"""
    s = StringIO()

    print&gt;&gt;s, self.name, self.n1, self.n2, self.value,

    for k, v in self.param.iteritems():
        print&gt;&gt;s, k+'='+str(v),

    return _wrapper.fill(s.getvalue())
</t>
<t tx="etihwnad.20060605200356.14">def drop(self, val=0.0, mode='&lt;'):
    """Indicate whether to drop the element from the list.
    Occurs iff (val 'mode' self.value)

    Can this be converted to specifying an arbitrary binary function?
      This may allow a more elegant comparison.
      e.g. mode = &lt; instead of mode = '&lt;' or mode = cap_smaller(x, y)
    """
    if mode == '&lt;':
        if self.value &lt; val: return True
    elif mode == '&lt;=':
        if self.value &lt;= val: return True
    elif mode == '&gt;':
        if self.value &gt; val: return True
    elif mode == '&gt;=':
        if self.value &gt;= val: return True
    else:
        return False
    return False #shouldn't get here, but...
</t>
<t tx="etihwnad.20060605200356.15">
class Capacitor(Passive2NodeElement):
    """Assumes SPICE element line:

    cXXX n1 n2 value p1=val p2=val ...
    Provides:
        isparallel(other)
        combine(other)
    """
	@others
_elementHandler.add_handler('c', Capacitor)
</t>
<t tx="etihwnad.20060605200356.16">def __init__(self, line, num):
    Passive2NodeElement.__init__(self, line, num)
    self.type = 'c'
    self.typeName = 'Capacitor'
</t>
<t tx="etihwnad.20060605200356.17">def isparallel(self, other):
    """Returns True if instance is parallel with other instance
    """
    if self.n1 == other.n1 and self.n2 == other.n2:
        return True
    elif self.n1 == other.n2 and self.n2 == other.n1:
        return True
    else:
        return False
</t>
<t tx="etihwnad.20060605200356.18">def combine(self, other):
    """Adds values if capacitors are in parallel, returns True if
    it combined them.

    NOTE: Does not currently touch param dictionary when combining,
      just the values.  How should this be done?  Maybe combine iff
      params are identical to avoid problems?
    """
    global _ncombine_capacitors
    if self.isparallel(other):
        self.value += other.value
        _ncombine_capacitors += 1
        return True
    else:
        return False
</t>
<t tx="etihwnad.20060605200356.19">
class Mosfet(SpiceElement):
    """Mosfet constructor takes an array derived from the
    netlist line
    """
	@others
_elementHandler.add_handler('m', Mosfet)
</t>
<t tx="etihwnad.20060605200356.20">def __init__(self, line, num):
    if isinstance(line, str):
        line = line.split()
    self.line = line
    self.type = 'm'
    self.typeName = 'Mosfet'
    self.num = num
    self.d = line[1]
    self.g = line[2]
    self.s = line[3]
    self.b = line[4]
    self.model = line[5]
    self.param = dict()
    for p in line[6:]:
        k, v = p.split('=')
        self.param[k] = unit(v)
    self.w = self.param['w']
    self.l = self.param['l']
</t>
<t tx="etihwnad.20060605200356.21">def __str__(self):
    s = StringIO()
    print&gt;&gt;s, self.line[0], self.d, self.g, self.s, self.b, self.model,
    for k, v in self.param.iteritems():
        if v == 0: continue
        print&gt;&gt;s, k + '=' + str(v),
    return _wrapper.fill(s.getvalue())
</t>
<t tx="etihwnad.20060605200356.22">def isparallel(self, other):
    """Returns True if transistors are parallel
    """
    # check gate, substrate, and model first
    if self.g == other.g and self.b == other.b and self.model == other.model:
        #source and drain can be reversed
        if self.d == other.d and self.s == other.s:
            return True
        elif self.d == other.s and self.s == other.d:
            return True
        else:
            return False
    else:
        return False

</t>
<t tx="etihwnad.20060605200356.23">def combine(self, other):
    """Combines adds other to self iff the transistors are identical,
    will NOT combine if W/L is different.  Parameter 'M' is incremented on
    self, other is left alone.

    Returns True if it combined the transistors.

    Increments global _ncombine_mosfets for information.

    NOTE: This currently merely adds the parameters (except w, l, and m)
    without regard to their meaning.  Here is the place to specially handle
    certain FET parameters.  Average certain parameters?
    """
    global _ncombine_mosfets
    if self.isparallel(other):
        #combine iff W/L (for original FET) is same also
        if self.w == other.w and self.l == other.l:
            for k, v in other.param.iteritems():
                if k == 'w' or k == 'l' or k == 'm': continue
                self.param[k] += v
            if ('m' in self.param.keys()) or ('m' in other.param.keys()):
                #add other's M parameter or increment
                self.param['m'] += other.param.get('m', 1)
            else:
                self.param['m'] = 2

            _ncombine_mosfets += 1
            return True
    else:
        return False
</t>
<t tx="etihwnad.20060605200356.24">
class Resistor(Passive2NodeElement):
    """Assumes SPICE element line:

    rXXX n1 n2 value p1=val p2=val ...
    """
	@others
_elementHandler.add_handler('r', Resistor)
</t>
<t tx="etihwnad.20060605200356.25">def __init__(self, line, num):
    Passive2NodeElement.__init__(self, line, num)
    self.type = 'r'
    self.typeName = 'Resistor'
</t>
<t tx="etihwnad.20060605200356.26">def info(message):
    """Print information to stderr."""
    for m in message.split('\n'):
        if m:
            print&gt;&gt;stderr, 'Info:', m
</t>
<t tx="etihwnad.20060605200356.27">def debug(message):
    """Print debugging info to stderr."""
    for m in message.split('\n'):
        if m:
            print&gt;&gt;stderr, 'Debug:', m
</t>
<t tx="etihwnad.20060605200356.28">def warning(message, elm=None, num=None):
    """Print warning to stderr.  If elm and num defined,
    print different message"""
    if elm and num:
        message = _opt.infile+":"+str(num)+" '"+elm+\
                "' type not defined yet, passing through..."
    print&gt;&gt;stderr, 'Warning:', message
</t>
<t tx="etihwnad.20060605200356.29">def drop_2node(elm,val,mode='&lt;',type=None, verbose=True):
    """Drop 2-node elements in elm list according to val.

    mode = '&lt;' | '&gt;'
    type - print info on what and how many it dropped
    Note: only works correctly for capacitors for now
    """
    new_elm=[]
    val=float(val)
    for i in elm:
        if mode=='&lt;' and i.value&gt;=val:
            new_elm.append(i)
        elif mode=='&gt;' and i.value&lt;=val:
            new_elm.append(i)
        else:
            continue
    #Print info about how many it dropped
    if verbose:
        infostr='Dropped '+str((len(elm)-len(new_elm)))+' '
        if type and type[-1]=='s':
            info(infostr+type)
        elif type:
            info(infostr+type+'s')
        else:
            info(infostr+'elements')
    return new_elm
</t>
<t tx="etihwnad.20060605200356.30">##
# write 2-node SPICE elements to file
# node pair is specified by key in dict:
#  "node0,node1"
##
#NOTE:
# this function is dying a slow, painful death.  Each element is
# getting its own custom __str__() method for writing to netlists.
#
def write_2node(elm, type=None, ofp=sys.stdout, comment=None):
    """Write 2-node SPICE elements to file

    elm - dictionary of elements
    type - SPICE element name
    ofp  - output file pointer
    comment - comment string at head of elm list

    Note: "type" must begin with a SPICE element letter, the rest is printed
    as identifying information, e.g. linductor, capacitor, mosfet.
    """
    if not type:
        raise SyntaxError('Must define a SPICE element name')
    i=1
    if comment:
        print&gt;&gt;ofp,'\n**\n* '+comment+'\n**'
    for k,v in elm.iteritems():
        node=k.split(',')
        print&gt;&gt;ofp, type[0]+str(i).rjust(3,'0'),node[0],node[1],v
        i+=1
    infostr='Wrote '+str(i)+' '+type
    if type[-1]=='s':
        info(infostr)
    else:
        info(infostr+'s')
</t>
<t tx="etihwnad.20060605200356.31">##
# Read netlist from open file object
#  -make sure if reading from stdin to read only once and
#   use this function to make sure you read the entire netlist
##
def read_netlist(fname):
    &lt;&lt; docstring &gt;&gt;
    &lt;&lt; imports &gt;&gt;

    if isinstance(fname,file):
        ifp=fname
    else:
        ifp=open(fname,'rU')
#    netlist=ifp.readlines()
    nline=0
    lines=[]    #raw expanded netlist
    #
    re_param=re.compile(r"(\S*)\s*=\s*(\S*)") 
    for line in ifp:
        line=line.strip('\r\n')
        #pass through empty lines
        if not len(line.split()):
            #convert empty line to comment as a placeholder
            lines.append('*')
            nline+=1
            continue #next please...
        #pass through comments, they stay asis
        elif line[0]=='*':
            lines.append(line)
            nline+=1
            continue #next please...
        #case is unimportant in SPICE
        line=line.lower()
        #remove whitespace in parameter assignments
        # to prepare for x.split(' ') that happens later:
        # 'as = 3e-12' =&gt; 'as=3e-12'
        line=re.sub(re_param,r'\1=\2',line)
        if line[0]!='+': #beginning of SPICE line
            lines.append(line)
            nline+=1
        else:            #line continuation
            line=line[1:]
            lines[-1]=lines[-1]+line
    return lines
</t>
<t tx="etihwnad.20060605200356.32">
class ElementError(LookupError):
	@others

</t>
<t tx="etihwnad.20060605200356.33">def __init__(self, elm='???'):
    self.elm = elm

</t>
<t tx="etihwnad.20060605200356.34">def __str__(self):
    return str('No class defined for this element: '+self.elm)

</t>
<t tx="etihwnad.20060605200356.35">def classify(net):
    """Reads expanded netlist and classifies each line,
    calls appropriate function to combine nodes.

    net - list of unwrapped SPICE netlist lines
    """
    # Is there a better (faster) way of doing this?  Maybe generating a dict
    # of handler functions and calling based on the first character.  At any
    # rate, it would make the classification a constant-time operation.
    import string
    elements=dict()
    global _counts
    global _opt
    opt=_opt
    #initialize to all element types
    for ch in '*.'+string.lowercase:
        elements[ch]=[]
        _counts[ch]=0
    num=-1 #line counter
    for line in net:
        num+=1
        arr=line.split()
        x=arr[0][0]

        # Comment
        if x=='*':
            elements[x].append(CommentLine(line,num))
            _counts[x]+=1

        # Control line
        elif x=='.':
            elements[x].append(ControlElement(line,num))
            _counts[x]+=1

        elif x=='a':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='b':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Capacitor
        elif x=='c':
            elm=Capacitor(line,num)
            #don't combine if it's the first encountered
            if _counts[x]==0:
                elements[x].append(elm)
            else:
                #combine if parallel or add if unique
                if opt.combine_c and elements[x][-1].combine(elm):
                    pass
                else:
                    elements[x].append(elm)
            _counts[x]+=1

        elif x=='d':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='e':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='f':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='g':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='h':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Current Source
        elif x=='i':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='j':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='k':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Inductor
        elif x=='l':
            elm=Inductor(line,num)
            #don't combine if it's the first encountered
            if _counts[x]==0:
                elements[x].append(elm)
            else:
                #combine if parallel or add if unique
                if elements[x][-1].combine(elm):
                    pass
                else:
                    elements[x].append(elm)
            _counts[x]+=1

        # Mosfet
        elif x=='m':
            elm=Mosfet(line,num)
            if _counts[x]==0:
                #don't combine if it's the first encountered
                elements[x].append(elm)
                #mosfets.append(elm)
            elif not opt.combine_m:
                #do not combine elements
                elements[x].append(elm)
            else:
                #search list backwards to find a parallel one
                #in case they aren't adjacent, faster?
                i=len(elements[x])-1
                while i&gt;=0:
                    if elements[x][i].combine(elm):
                        break
                    else:
                        i-=1
                #found unique MOSFET
                if i==-1:
                    elements[x].append(elm)
            _counts['m']+=1

        elif x=='n':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='o':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='p':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='q':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Resistor
        elif x=='r':
            elm=Resistor(line,num)
            elements[x].append(elm)
            _counts['r']+=1

        elif x=='s':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='t':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='u':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Voltage Source
        elif x=='v':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='w':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        # Subcircuit
        elif x=='x':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='y':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='z':
            elements[x].append(SpiceElement(line,num))
            warning('',elm=arr[0],num=num)
            _counts[x]+=1

        elif x=='+':
            raise Error('No line continuations (+) allowed.')

        else:
            raise Error('Encountered unknown element: '+line)

    #add 'special' elements to netlist
    #debugging/information header
    print&gt;&gt;ofp,'* Input Element counts'
    for k,v in _counts.iteritems():
        if v!=0: print&gt;&gt;ofp, '*',k,'-',v
    #return classified netlist
    return elements

</t>
<t tx="etihwnad.20060605200356.36">##
# Fancy option processing
##
def options(args=sys.argv):
    """Define options and parse argument list.
    """
    global ifp, ofp
    usage = """%prog [options]"""
    desc = """This script reads a SPICE input files and processes it according
    to the options given.  It is especially useful for processing netlists
    from the output of layout extractors by combining parallel C's and
    FET's.  More features added upon request."""

    parser = OptionParser(usage=usage, description=desc)

    parser.add_option('-i', '--infile', dest='infile', default='stdin',
                      help='Input SPICE file to be processed'
                           ', (default: %default)')

    parser.add_option('-o', '--outifle', dest='outfile', default='stdout',
                      help='Output file for changes'
                           ', (default: %default)')

    parser.add_option('-d', '--dropcap', dest='dropcap',
                      default='10', metavar='X',
                      help='Drop all capacitors smaller than X fF'
                           ', (default: %default)')

    parser.add_option('--no-combine-c', dest='combine_c', action='store_false',
                      default=True, help='Do not combine parallel capacitors')

    parser.add_option('--no-combine-m', dest='combine_m', action='store_false',
                      default=True, help='Do not combine parallel MOSFETs')

    parser.add_option('-v', '--verbose', dest='v', action='store_true',
                      default=True, help='Show info and debugging messages (default)')

    parser.add_option('-q', '--quiet', dest='v', action='store_false',
                      help='Suppress all messages on stderr')

    parser.add_option('-w', '--linewidth', dest='linewidth', default=75,
                      help='Max. line width for netlist (default: %default)')

    (opt, args) = parser.parse_args()

    #infile
    if opt.infile == 'stdin':
        ifp = sys.stdin
        if opt.v: info('Input: stdin')
    else:
        try:
            ifp = open(opt.infile, 'rU') #python's universal line ending mode
            if opt.v: info('Input: '+opt.infile)
        except IOError, (errno, strerror):
            print&gt;&gt;stderr, "IOError(%s): %s '%s'" % (errno, strerror, opt.infile)      

    #outfile
    if opt.outfile == 'stdout':
        ofp = sys.stdout
        if opt.v: info('Output: stdout')
    else:
        try:
            ofp = open(opt.outfile, 'w')
            if opt.v: info('Output: ' + opt.outfile)
        except IOError, (errno, strerror):
            print&gt;&gt;stderr, "IOError(%s): %s '%s'" % (errno, strerror, opt.infile)

    #dropcap
    opt.dropcap = float(opt.dropcap)
    opt.dropcap = opt.dropcap * 1e-15
    if opt.v:
        info('Dropping caps &lt; ' + str(opt.dropcap) + ' F')
        info("Combining c's: " + str(opt.combine_c))
        info("Combining m's: " + str(opt.combine_m))

    #linewidth
    _wrapper.line_width = opt.linewidth

    return opt

</t>
<t tx="etihwnad.20060605200356.37">####
# 
# test code
# 
####
def main():
    global _opt
    opt = options()
    _opt=opt

    import textwrap
    #set line continuation style and max width
    _wrapper=textwrap.TextWrapper(subsequent_indent='+ ',width=opt.linewidth)

    print&gt;&gt;ofp,"* pyspice.py: by Dan White &lt;etihwnad at gmail dot com&gt;"
    print&gt;&gt;ofp,"* mail me bug reports, fixes, and comments if you find this useful"
    print&gt;&gt;ofp,"* ----------------------------------------------------------------"

    netlist = read_netlist(ifp)
    nlist_new=classify(netlist)

    info('Combined %i parallel capacitors' % _ncombine_capacitors)
    info('Combined %i parallel mosfets' % _ncombine_mosfets)

    nlist_new['c']=drop_2node(nlist_new['c'], opt.dropcap, type='capacitor')


    #create a new list of netlist objects
    #in order of first appearance
    all=[]
    print '*\n* Output Element counts'
    for type in nlist_new.keys():
        num=len(nlist_new[type])
        if num:
            print '*',type,'-',num
        for elm in nlist_new[type]:
            all.append(elm)

    #python2.4 specific operation
    #sort netlist by order of appearance in orig. netlist
    all.sort(cmp=lambda x,y: cmp(x.num,y.num))
    for x in all:
        print&gt;&gt;ofp,x
</t>
<t tx="etihwnad.20060605201903">Copyright Dan White 2006-8

Licensed by the GPL, see http://www.whiteaudio.com/soft/COPYING or the current
GNU GPL license for details.

</t>
<t tx="etihwnad.20060605202504">pyspice.py v0.3

SPICE pre-processor that combines parallel elements (e.g. capacitors, mosfets)
for GREATLY reduced simulation time.  Uses the 'M' parameter of MOSFETS
when combining parallel FETs.  Makes simulating fingered transistors easier and
faster.

 Combine parallel capacitors
 Drop combined caps smaller than X fF
 Usage:
  pyspice.py [options] [-i infile] [-o outfile]

 Use pyspice.py -h for all the options.
</t>
<t tx="etihwnad.20060605202632.1">
TODO:
xpreserve comments in position
-element class definitions
    xinductor
    xv-source
    xi-source
    -e-source (VCVS)
-preserve node namespaces (within subckts, libraries, etc.)
    -find illegal SPICE node name character to prepend namespace
     e.g. @sub1.node1
-handle control statements specially
    -.model
    -.dc, .ac, .tran
    -.lib/.endl handling
    -.meas
    -.print
    -.probe
    -.param
    -.option
    -.global
    -.ic
    -.subckt/.ends
    -.prot/.unprot
    -.alter blocks
    -.end
    -others?
-option to find/evaluate .param statements?
    -HSPICE takes params, ngspice doesn't
    -logic to find when an explicit number is specified (e.g. 10k) or
     when it is a parameter (e.g. 'value')
    -create dict of .params and use as substitution keys in:
        k = v model parameters
        node names
        element values (Rxx n1 n2 'value'; Cxx n1 n2 'fc/2')
        others?
-option to make a flat output (inline everything):
    .lib statements
    .include statements
    .model statements
    others?
-store node dictionary to keep track of elements connected to that node
    -allows tracking of R-C nodes to drop C or R based on time constant
    -allows more sophisticated dropping/combining with series elements
        specifically R+R+R+R chains -&gt; equivalent R+- (roughly) for faster sims
                      C C C                        C
</t>
<t tx="etihwnad.20060605205852">##
# Global Shorthands
##
stderr = sys.stderr

#set line continuation style and max width
_wrapper = textwrap.TextWrapper(subsequent_indent = '+ ', width = 75)


#global variables
_counts = dict() #keyed by spice element letter
_ncombine_capacitors = 0
_ncombine_inductors = 0
_ncombine_mosfets = 0
_ncombine_res = 0

#namespace tracking
# -not implemented yet
_current_scope = ''
</t>
<t tx="etihwnad.20060605210612">
##
# Global imports
##
import getopt
import re
import sys
import textwrap
import warnings

from decimal import Decimal
from optparse import OptionParser

try:
    from cStringIO import StringIO as StringIO
except:
    from StringIO import StringIO as StringIO
</t>
<t tx="etihwnad.20060605211347"></t>
<t tx="etihwnad.20060606092308.1">@first #!/usr/bin/env python
@language python
@tabwidth -4

__version__ = '0.3'

&lt;&lt; head docstring &gt;&gt;
&lt;&lt; global imports &gt;&gt;
&lt;&lt; global vars &gt;&gt;

@
Debug options: string of debugging elements to print
* - comments
follow SPICE element names (c-capacitor, l-inductor)
@c
dbg = ''

@others

#magic script-maker
if __name__ == '__main__':
    main()
</t>
<t tx="etihwnad.20060609195838"></t>
<t tx="etihwnad.20060609195838.1"></t>
<t tx="etihwnad.20060609200142">"""Read a SPICE netlist from the open file pointer

read_netlist(filename) -&gt; array lines

Returns a list of expanded lines (without continuation '+')
Keeps case of comments, all other lines are lowercased

return:
    netlist (list) of SPICE netlist lines
"""
</t>
<t tx="etihwnad.20060609200142.1">import re
</t>
<t tx="etihwnad.20060612075426">RE_UNIT = re.compile(r'^([0-9e\+\-\.]+)(t|g|meg|x|k|mil|m|u|n|p|f)?')
def unit(s):
    """Takes a string and returns the equivalent float.
    '3.0u' -&gt; 3.0e-6"""
    mult = {'t'  :Decimal('1.0e12'),
            'g'  :Decimal('1.0e9'),
            'meg':Decimal('1.0e6'),
            'x'  :Decimal('1.0e6'),
            'k'  :Decimal('1.0e3'),
            'mil':Decimal('25.4e-6'),
            'm'  :Decimal('1.0e-3'),
            'u'  :Decimal('1.0e-6'),
            'n'  :Decimal('1.0e-9'),
            'p'  :Decimal('1.0e-12'),
            'f'  :Decimal('1.0e-15')}

    m = RE_UNIT.search(s.lower())
    try:
        if m.group(2):
            return Decimal(Decimal(m.group(1)))*mult[m.group(2)]
        else:
            return Decimal(m.group(1))
    except:
        raise BadUnitError
</t>
<t tx="etihwnad.20060612195947">
class Inductor(Passive2NodeElement):
    """Assumes SPICE element line:

    cXXX n1 n2 value p1=val p2=val ...
    Provides:
        isparallel(other)
        combine(other)
    """
	@others
_elementHandler.add_handler('l', Inductor)
</t>
<t tx="etihwnad.20060612195947.1">def __init__(self, line, num):
    Passive2NodeElement.__init__(self, line, num)
    self.type = 'l'
    self.typeName = 'Inductor'
</t>
<t tx="etihwnad.20060612195947.2">def isparallel(self, other):
    """Returns True if instance is parallel with other instance
    """
    if self.n1 == other.n1 and self.n2 == other.n2:
        return True
    elif self.n1 == other.n2 and self.n2 == other.n1:
        return True
    else:
        return False
</t>
<t tx="etihwnad.20060612195947.3">def combine(self, other):
    """Combines values if inductors are in parallel, returns True if
    it combined them.

    NOTE:
     -Does not currently touch param dictionary when combining,
      just the values.  How should this be done?
    """
    global _ncombine_inductors
    if self.isparallel(other):
        self.value = (self.value*other.value)/(self.value+other.value)
        _ncombine_inductors += 1
        return True
    else:
        return False
</t>
</tnodes>
</leo_file>
